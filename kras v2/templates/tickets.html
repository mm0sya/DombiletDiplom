{% extends "base.html" %}
{% block title %}{{ match.teams }}{% endblock %}

{% block head %}
    <style>
        .hero-section {
            background-image: url('/static/backgrounds/{{ match.image }}');
            height: 1000px;
            width: 100%;
        }
    </style>
    <script src="/static/js/utils.js"></script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
    </script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
        return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
    </script>
    <script>
        function selectSector(sectorName) {
            const matchId = "{{ match.slug }}";
            window.location.href = `/sector_view/${matchId}/${sectorName}`;
        }
    
        function scrollToStadiumMap() {
            const stadiumMap = document.querySelector('.stadium-map');
            const offset = 100; // Задайте значение смещения
            const elementPosition = stadiumMap.getBoundingClientRect().top + window.scrollY;
            const offsetPosition = elementPosition - offset;

            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });
        }
    
        function formatDate(dateString, timeString) {
            const months = [
                'Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня',
                'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября', 'Декабря'
            ];
            const date = new Date(dateString + 'T' + (timeString || '00:00'));
            const day = date.getDate();
            const month = months[date.getMonth()];
            const year = date.getFullYear();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${day} ${month} ${year}, ${hours}:${minutes}`;
        }
    
        function toggleTickets() {
            const ticketsSection = document.querySelector('.tickets-section');
            ticketsSection.classList.toggle('active');
        }
    
        window.onload = function() {
            updateCartCount();
            const dateElement = document.querySelector('.match-info .date');
            const rawDate = dateElement.getAttribute('data-date');
            const rawTime = dateElement.getAttribute('data-time');
            dateElement.textContent = formatDate(rawDate, rawTime);
        };
    
        document.addEventListener('DOMContentLoaded', function () {
            const tooltip = document.getElementById('sector-tooltip');
            const sectors = document.querySelectorAll('.sector.active');
            const filterButtons = document.querySelectorAll('.price-filter');
            let activeFilter = null;
    
            sectors.forEach(sector => {
                const sectorName = sector.getAttribute('data-id');
    
                sector.addEventListener('mouseover', function (e) {
                    const availableSeats = getAvailableSeats(sectorName);
                    const priceRange = getSectorPriceRange(sectorName);
    
                    tooltip.querySelector('.sector-name').textContent = `Сектор ${sectorName}`;
                    tooltip.querySelector('#available-seats').textContent = availableSeats;
                    if (priceRange.min === priceRange.max) {
                        tooltip.querySelector('#sector-price').textContent = priceRange.min;
                    } else {
                        tooltip.querySelector('#sector-price').textContent = priceRange.min + '–' + priceRange.max;
                    }
    
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.pageX + 10 + 'px';
                    tooltip.style.top = e.pageY + 10 + 'px';
                });
    
                sector.addEventListener('mousemove', function (e) {
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
    
                    let left = e.pageX + 10;
                    let top = e.pageY + 10;
    
                    if (left + tooltipWidth > windowWidth) {
                        left = e.pageX - tooltipWidth - 10;
                    }
    
                    if (top + tooltipHeight > windowHeight) {
                        top = e.pageY - tooltipHeight - 10;
                    }
    
                    if (left < 0) {
                        left = 10;
                    }
    
                    if (top < 0) {
                        top = 10;
                    }
    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                });
    
                sector.addEventListener('mouseout', function () {
                    tooltip.style.display = 'none';
                });
            });
    
            function getAvailableSeats(sectorName) {
                const sector = {{ match.sectors | tojson | safe }}.find(s => s.name === sectorName);
                if (sector && sector.seats) {
                    return sector.seats.filter(seat => seat.available).length;
                }
                return 0;
            }
    
            function getSectorPriceRange(sectorName) {
                const sector = {{ match.sectors | tojson | safe }}.find(s => s.name === sectorName);
                if (sector && sector.seats) {
                    const prices = sector.seats.filter(seat => seat.available).map(seat => seat.price);
                    if (prices.length > 0) {
                        return {min: Math.min(...prices), max: Math.max(...prices)};
                    }
                }
                return {min: 0, max: 0};
            }
    
            // Функция для применения подсветки и затемнения секторов
            function applySectorHighlight(minPrice, maxPrice, isPreview = false) {
                sectors.forEach(sector => {
                    const sectorName = sector.getAttribute('data-id');
                    const price = getSectorPriceRange(sectorName);
    
                    if (price.min >= minPrice && price.max <= maxPrice) {
                        sector.classList.remove('dimmed');
                        sector.classList.add('highlighted');
                    } else if (isPreview) {
                        sector.classList.add('dimmed');
                        sector.classList.remove('highlighted');
                    }
                });
            }
    
            // Функция для восстановления состояния секторов
            function restoreSectorState() {
                sectors.forEach(sector => {
                    const sectorName = sector.getAttribute('data-id');
                    const price = getSectorPriceRange(sectorName);
    
                    if (activeFilter) {
                        const minPrice = parseInt(activeFilter.getAttribute('data-min'));
                        const maxPrice = parseInt(activeFilter.getAttribute('data-max'));
                        if (price.min >= minPrice && price.max <= maxPrice) {
                            sector.classList.remove('dimmed');
                            sector.classList.add('highlighted');
                        } else {
                            sector.classList.add('dimmed');
                            sector.classList.remove('highlighted');
                        }
                    } else {
                        sector.classList.remove('dimmed', 'highlighted');
                    }
                });
    
                // Восстанавливаем состояние кнопок
                filterButtons.forEach(btn => {
                    if (activeFilter && btn !== activeFilter) {
                        btn.classList.add('dimmed');
                    } else {
                        btn.classList.remove('dimmed');
                    }
                });
            }
    
            // Код для фильтрации и предпросмотра
            filterButtons.forEach(button => {
                // Обработка клика для установки активного фильтра
                button.addEventListener('click', function () {
                    const minPrice = parseInt(button.getAttribute('data-min'));
                    const maxPrice = parseInt(button.getAttribute('data-max'));
    
                    // Если фильтр уже активен, сбрасываем его
                    if (activeFilter === button) {
                        sectors.forEach(sector => {
                            sector.classList.remove('dimmed', 'highlighted');
                        });
                        filterButtons.forEach(btn => {
                            btn.classList.remove('dimmed');
                        });
                        activeFilter.classList.remove('active');
                        activeFilter = null;
                        return;
                    }
    
                    // Удаляем предыдущий активный фильтр
                    if (activeFilter) {
                        activeFilter.classList.remove('active');
                    }
    
                    // Применяем новый фильтр
                    button.classList.add('active');
                    activeFilter = button;
    
                    // Применяем подсветку секторов
                    applySectorHighlight(minPrice, maxPrice);
    
                    // Затемняем кнопки фильтров, не соответствующие активному фильтру
                    filterButtons.forEach(btn => {
                        if (btn !== activeFilter) {
                            btn.classList.add('dimmed');
                        } else {
                            btn.classList.remove('dimmed');
                        }
                    });
                });
    
                // Обработка наведения для предпросмотра
                button.addEventListener('mouseover', function () {
                    const minPrice = parseInt(button.getAttribute('data-min'));
                    const maxPrice = parseInt(button.getAttribute('data-max'));
    
                    // Применяем подсветку для предпросмотра
                    applySectorHighlight(minPrice, maxPrice, true);
    
                    // Затемняем остальные кнопки фильтров
                    filterButtons.forEach(btn => {
                        if (btn !== button) {
                            btn.classList.add('dimmed');
                        } else {
                            btn.classList.remove('dimmed');
                        }
                    });
                });
    
                // Обработка отведения курсора
                button.addEventListener('mouseout', function () {
    
                    // Восстанавливаем состояние секторов и кнопок
                    restoreSectorState();
                });
            });
        });
    </script>
    <link rel="stylesheet" href="/static/css/tickets.css">
{% endblock %}

{% block content %}
    <section class="hero-section">
    </section>
    <main style="max-width: 1400px; margin-left: auto; margin-right: auto;">
        {% set all_prices = [] %}
        {% for sector in match.sectors %}
            {% for seat in sector.seats %}
                {% if seat.available %}
                    {% set _ = all_prices.append(seat.price) %}
                {% endif %}
            {% endfor %}
        {% endfor %}

        <div class="match-info">
            <div style="position: relative; width: 100%;">
                <div class="header-info">
                    <div class="match-type">⚽ Футбольный матч</div>
                    <div class="location">📍 г. Краснодар, площадка: OZON арена</div>
                    <div class="price-section">
                        <div class="price">Стоимость: <span>От {{ all_prices|min }} ₽</span></div>
                    </div>
                </div>
                <h2>Билеты на <span>{{ match.teams }}</span></h2>
                <p class="date" data-date="{{ match.date }}" data-time="{{ match.time|default('00:00') }}"></p>
                <div class="buy-section">
                    <a class="scroll-button" onclick="scrollToStadiumMap()">Перейти к покупке</a>
                </div>
            </div>
        </div>

        <div class="info-section">
            <div class="info-wrapper">
                <div class="info-container">
                    <div class="info-block">
                        <h3><span class="number">1</span> Как выбрать места?</h3>
                        <p>Свободные места подсвечивы цветом. Выберите сектор, интересующие вас места и нажмите иконку оформления заказа для ввода контактных данных.</p>
                    </div>
                    <div class="info-block">
                        <h3><span class="number">2</span> Как оплатить билеты?</h3>
                        <p>На странице оформления заказа выберите удобный для вас способ оплаты: банковской картой или наличными курьеру при получении билетов.</p>
                    </div>
                    <div class="info-block">
                        <h3><span class="number">3</span> Как получить билеты?</h3>
                        <p>С помощью бесплатной доставки или самовывоза. Для удобства воспользуйтесь электронными билетами, которые придут вам на почту.</p>
                    </div>
                </div>
            </div>
        </div>

        {% include 'stadium_map.html' %} <!--  подгрузка svg стадиона   -->

        <div id="sector-tooltip" class="tooltip">
            <p class="sector-name">Сектор</p>
            <p>Свободных мест: <span id="available-seats">0</span></p>
            <p class="price">Цена: <span id="sector-price">0</span> ₽</p>
        </div>

            <div class="contact-section">
                <div class="contact-text">
                    Если у вас возникли вопросы, звоните по номеру <a href="tel:7(900)777-77-77"> +7(900) 777-77-77</a>
                </div>
            </div>
        </div>
    </main>
{% endblock %}